-- [nfnl] fnl/conjure/client/scheme/keywords.fnl
local _local_1_ = require("conjure.nfnl.module")
local autoload = _local_1_["autoload"]
local define = _local_1_["define"]
local a = autoload("conjure.nfnl.core")
local M = define("conjure.client.scheme.keywords")
local lang_keywords = {}
local common_keywords = {"*", "+", "-", "/", "<", "<=", "=", ">", ">=", "abs", "acos", "and", "angle", "append", "apply", "asin", "assoc", "assq", "assv", "atan", "begin", "boolean?", "caaaar", "caaadr", "caaar", "caadar", "caaddr", "caadr", "caar", "cadaar", "cadadr", "cadar", "caddar", "cadddr", "caddr", "cadr", "call-with-current-continuation", "call-with-input-file", "call-with-output-file", "call-with-values", "call/cc", "car", "case", "cdaaar", "cdaadr", "cdaar", "cdadar", "cdaddr", "cdadr", "cdar", "cddaar", "cddadr", "cddar", "cdddar", "cddddr", "cdddr", "cddr", "cdr", "ceiling", "char->integer", "char-alphabetic?", "char-ci<=?", "char-ci<?", "char-ci=?", "char-ci>=?", "char-ci>?", "char-downcase", "char-lower-case?", "char-numeric?", "char-ready?", "char-upcase", "char-upper-case?", "char-whitespace?", "char<=?", "char<?", "char=?", "char>=?", "char>?", "char?", "close-input-port", "close-output-port", "complex?", "cond", "cons", "cos", "current-error-port", "current-input-port", "current-output-port", "define", "define-syntax", "delay", "denominator", "display", "do", "dynamic-wind", "eof-object?", "eq?", "equal?", "eqv?", "error", "eval", "even?", "exact->inexact", "exact-integer-sqrt", "exact?", "exit", "exp", "expt", "finite?", "fixnum?", "floor", "for-each", "force", "gcd", "get-output-string", "if", "imag-part", "inexact->exact", "inexact?", "infinite?", "input-port?", "integer->char", "integer?", "interaction-environment", "lambda", "lcm", "length", "let", "let*", "let-syntax", "letrec", "letrec-syntax", "list", "list->string", "list->vector", "list-ref", "list-tail", "list?", "load", "log", "magnitude", "make-parameter", "make-polar", "make-rectangular", "make-string", "make-vector", "map", "max", "member", "memq", "memv", "min", "modulo", "nan?", "negative?", "newline", "not", "null-environment", "null?", "number->string", "number?", "numerator", "odd?", "open-input-file", "open-input-string", "open-output-file", "open-output-string", "or", "output-port?", "pair?", "peek-char", "port?", "positive?", "procedure?", "quasiquote", "quote", "quotient", "rational?", "rationalize", "read", "read-char", "real-part", "real?", "remainder", "reverse", "round", "scheme-report-environment", "set!", "set-car!", "set-cdr!", "sin", "sqrt", "string", "string->list", "string->number", "string->symbol", "string->uninterned-symbol", "string-append", "string-ci<=?", "string-ci<?", "string-ci=?", "string-ci>=?", "string-ci>?", "string-copy", "string-fill!", "string-length", "string-ref", "string-set!", "string<=?", "string<?", "string=?", "string>=?", "string>?", "string?", "substring", "symbol->string", "symbol?", "syntax-error", "syntax-rules", "tan", "truncate", "unquote", "unquote-splicing", "values", "vector", "vector->list", "vector-fill!", "vector-length", "vector-ref", "vector-set!", "vector?", "weak-cons", "weak-pair?", "with-input-from-file", "with-output-to-file", "write", "write-char", "zero?"}
a.assoc(lang_keywords, "common", common_keywords)
a.assoc(lang_keywords, "guile", a.concat(common_keywords, {"ice-9", "srfi", "debug", "expect", "format", "ftw", "getopt-long", "history", "popen", "pretty-print", "q", "rdelim", "readline", "receive", "regex", "rw", "streams", "syncase", "threads", "documentation", "srfi-1", "srfi-2", "srfi-4", "srfi-6", "srfi-8", "srfi-9", "srfi-10", "srfi-11", "srfi-13", "srfi-14", "srfi-16", "srfi-17", "srfi-19", "srfi-26", "srfi-31"}))
M["get-set"] = function(key)
  return a.get(lang_keywords, key, common_keywords)
end
return M
